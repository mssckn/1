//1- The 3n + 1 problem
#include <iostream>

using  namespace std;
int main() {
    char c;
    bool flag = true;
    while (cin.get(c)){
        if (c == '"')
        {
            if (flag)
                cout <<"``";
            else
                cout <<"''";
            flag = !flag ;
        }
        else
            cout << c;
    }

    return 0;
}

//2- TeX Quotes
#include <iostream>
using namespace std;

string s;
int cnt, blk;

int main() {
    while (getline(cin, s)){
        for (int i = 0; i < s.length(); i++){
            if (s[i] == '\"'){
                if (cnt % 2 == 0) cout << "``";
                else cout << "''";
                cnt++;
            }
            else cout << s[i];
        }
        cout << "\n";
    }
}

//3- WERTYU
#include <iostream>
#include <string>
using namespace std;
int main() {
    string keyboard = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./";
    char c ;
    int i ;
    while (cin.get(c)){
        if (c==' '||c== '\n')
            cout <<c;
        else {
            i = keyboard.find(c);
            cout << keyboard[i-1];
        }
    }

    return 0;
}

//4- Palindromes
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;
string  originalT = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789";
string mirrorT =    "A   3  HIL JM O   2TUVWXY51SE Z  8 ";
bool isP(string s){
    string rs = s;
    reverse(rs.begin(),rs.end());
return rs ==s;
}
bool isM (string s){
    int index;
    string rs = s;
    reverse(rs.begin(),rs.end());
    for (int i = 0;i<s.size();i++){
        index = originalT.find(rs[i]);
        rs[i] = mirrorT[index];
    }
return rs ==s;

}
int main() {
   string s;
   bool p,m;
   while (cin >>s){
       p =isP(s);
       m =isM(s);
       cout <<s<<" -- is ";
       if ( p && m)
           cout << "a mirrored palindrome.";
       else if (p)
           cout << "a regular palindrome.";
       else if (m)
           cout << "a mirrored string.";
       else
           cout << "not a palindrome.";
       cout << "\n\n";

   }
    return 0;
}

//5- Master-Mind Hints
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {

    int game = 0;
    int n ;
    int A,B,zeroNum,sc,gc;
    vector <int> s(n);
    vector <int> g(n);

    while (cin >> n &&n!=0)
    {
        printf ("Game %d:\n",++game);
        for (int i=0 ; i<n ; i++)
        {
            cin >>s[i];
        }
        while (true)
        {
            A =0;
            zeroNum = 0;
            for (int i = 0; i<n ;i++)
            {
                cin >> g[i];
                if (s[i] == g[i] )
                    A++;
                if (g[i] == 0)
                    zeroNum++;
            }
            if (zeroNum == n)
                break;
            B =0;
            for ( int d= 0; d<=9; d++)
            {
                sc = 0;
                gc = 0;
                for (int i=0; i<n; i++)
                {
                    if (s[i] ==d )
                        sc++;
                    if (g[i] ==d )
                        gc++;
                }
                B += min (sc,gc);
            }
            printf("    (%d,%d)\n",A,B-A);
        }
    }
    return 0;
}

//6- Digit Generator01583 - Digit Generator
#include <iostream>

using namespace std;

int t[100001] = {0};

int main() {
    int x, y;
    int T, m;

    for(int n=0; n<=100000; n++) {
        y = n;
        x = n;

        while(x > 0) {
            y = y + x % 10;
            x = x / 10;
        }

        if(y > 100000)
            continue;
        if(t[y] == 0)
            t[y] = n;
    }

    cin >> T;
    while(T--) {
        cin >> m;
        cout << t[m] << endl;
    }

    return 0;
}

//7- 最大矩形 max matrix
#include <iostream>

using namespace std;

int main() {
    int m,n;
    int area,width;
    while (cin>>m>>n){
        int arr[m][n];
        for (int i =0;i<m;i++)
        {
            for (int j=0; j<n; j++)
            {
                cin>> arr[i][j];
            }
        }
        for (int i=0;i<m;i++){
            for(int j=1; j<n ;j++){
                if (arr[i][j])
                    arr[i][j] = arr[i][j-1] +1;
            }
        }
        area = 0;
        for (int i =0;i<m;i++){
            for(int j =0;j<n;j++){
                width =201;
                for (int h=0; h<=i && arr[i-h][j]; h++){
                    width = min(width,arr[i-h][j]);
                    area = max (area, width*(h+1));
                }
            }
        }
        cout <<area<<endl;
    }
    return 0;
}

//8- Ancient Cipher

#include <iostream>
using namespace std;

int a[26], b[26], n[105], m[105], l;
string s1, s2;

int main() {
    while (cin >> s1 >> s2){
        l = s1.length();
        for (int i = 0; i < 26; i++){
            a[i] = 0;
            b[i] = 0;
        }
        for (int i = 0; i < l; i++){
            a[s1[i]-'A']++;
            b[s2[i]-'A']++;
            n[i] = 0;
            m[i] = 0;
        }
        for (int i = 0; i < 26; i++){
            n[a[i]]++;
            m[b[i]]++;
        }
        bool flag = true;
        for (int i = 0; i < l; i++){
            if (n[i] != m[i]){
                flag = false;
                break;
            }
        }
        if (flag) cout << "YES\n";
        else cout << "NO\n";
    }
}

//9- Where is the marble
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    cin.sync_with_stdio(false), cin.tie(nullptr);
    int timesCount = 1, amount, queries, target, numbers[10000], *index;
    while (cin >> amount >> queries, amount && queries) {
        cout << "CASE# " << timesCount++ << ":\n";
        for (int i = 0; i < amount; ++i)
            cin >> numbers[i];
        sort(numbers, numbers + amount);
        while (queries--) {
            cin >> target, cout << target;
            index = lower_bound(numbers, numbers + amount, target);
            if (index == numbers + amount || *index != target)
                cout << " not found\n";
            else
                cout << " found at " << (int)(index - numbers + 1) << '\n';
        }
    }
}

//10- The Blocks Problem
#include <iostream>
#include <vector>
using namespace std;

int n, a, b, pos[25], pa, pb;
string s1, s2;
vector <int> v[25];

int main() {
    while (cin >> n){
        for (int i = 0; i < n; i++){
            v[i].clear();
            v[i].push_back(i);
            pos[i] = i;
        }
        while (cin >> s1){
            if (s1 == "quit") break;
            cin >> a;
            cin >> s2;
            cin >> b;
            pa = pos[a];
            pb = pos[b];
            if (pos[a] == pos[b]) continue;
            if (s2 == "onto"){
                for (int i = v[pb].size()-1; i >= 0; i--){
                    if (v[pb][i] == b) break;
                    pos[v[pb][i]] = v[pb][i];
                    v[v[pb][i]].push_back(v[pb][i]);
                    v[pb].pop_back();
                }
            }
            if (s1 == "move"){
                for (int i = v[pa].size()-1; i >= 0; i--){
                    if (v[pa][i] == a){
                        pos[v[pa][i]] = pb;
                        v[pb].push_back(a);
                        v[pa].pop_back();
                        break;
                    }
                    pos[v[pa][i]] = v[pa][i];
                    v[v[pa][i]].push_back(v[pa][i]);
                    v[pa].pop_back();
                }
            }
            else {
                for (int i = v[pa].size()-1; i >= 0; i--){
                    if (v[pa][i] == a){
                        for (int j = i; j < v[pa].size(); j++){
                            pos[v[pa][j]] = pb;
                            v[pb].push_back(v[pa][j]);
                        }
                        for (int j = v[pa].size(); j > i; j--){
                            v[pa].pop_back();
                        }
                        break;
                    }
                }
            }
        }
        for (int i = 0; i < n; i++){
            cout << i << ":";
            for (int j:v[i]){
                cout << " " << j;
            }
            cout << "\n";
        }
    }
}

//11-Throwing cards away I 
#include <iostream>
#include <queue>
using namespace std;

int main() {
    int n;
    while (cin >> n){
        if (n == 0) break;
        queue <int> q;
        for (int i = 0; i < n; i++){
            q.push(i+1);
        }
        cout << "Discarded cards:";
        for (int i = 0; i < n-1; i++){
            if (i != 0) cout << ',';
            cout << ' ' << q.front();
            q.pop();
            q.push(q.front());
            q.pop();
        }
        cout << endl << "Remaining card: " << q.front() << endl;
    }
}

//12- 傳送點
#include <iostream>
#include <queue>
 using namespace std;
int  S[1000000];
int count [1000000];
int main() {
    int n,P,L,R;
    int currentP,newL,newR;
    queue<int> q;
    cin >> n >> P >> L >> R;
    for (int i=0; i<n ; i++)
    {
        cin >>S[i];
    }
    q.push (0);
    while (true){
        if (q.empty()){
            cout << -1;
            break;
        }
        currentP = q.front();
        q.pop();
        if (currentP ==P){
            cout << count[currentP];
            break;
        }
        newL = currentP - L;
        if (newL >= 0){
            newL = S[newL];
            if (newL >=0 && newL <n && count[newL]==0){
                count[newL]= count[currentP]+1;
                q.push(newL);
            }
        }
        newR = currentP + R;
        if (newR < n){
            newR = S[newR];
            if (newR >= 0 && newR <n && count[newR]==0){
                count[newR]= count[currentP]+1;
                q.push(newR);
            }
        }
    }
    return 0;
}

//13- 括號問題
#include <iostream>
#include <stack>
using namespace std;

int main() {
    int n;
    string s;
    cin >> n;
    while (n--) {
        int count = 0;
        stack <int> stk;
        cin >> s;
        for (int j = 0; j < s.length(); j ++){
            if (!stk.empty() && stk.top() == '(' && s[j] == ')'){
                stk.pop();
                count ++;
            }else{
                stk.push(s[j]);
            }
        }
        if (!stk.empty()){
            count = 0;
        }
        cout << count << endl;
    }
}

//14-砍樹

#include<bits/stdc++.h>
using namespace std;
int n,l,num=0,maxd;
int c[100005];
int h[100005];
int le[100005];
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin >> n >>l;
    c[0]=h[0]=0;
    c[n+1]=h[n+1]=l;
    for(int x=1;x<=n;x++){cin >> c[x];le[x]=x-1;}
    for(int x=1;x<=n;x++)cin >> h[x];
    for(int x=1;x<=n;x++){
        if((c[x]-h[x]>=c[le[x]]) or (c[x]+h[x]<=c[x+1])){
            num++;
            le[x+1]=le[x];
            maxd=max(maxd,h[x]);
            while(true){
                if(le[x+1]>0 && c[le[x+1]]+h[le[x+1]]<=c[x+1]){
                    num++;
                    maxd=max(maxd,h[le[x+1]]);
                    le[x+1]=le[le[x+1]];

                }
                else{
                    break;
                }
            }
        }
    }
    if(num==0){
        cout << 0 << endl;
        cout << 0 << endl;
    }
    else{
        cout << num << endl;
        cout << maxd << endl;
    }

    return 0;
}

//15-Hangman Judge
#include <iostream>
#include <cstring>
using namespace std;

int n, ans[26], guess[26], r, w;
string s;
bool flag;

int main() {
    while (cin >> n){
        if (n == -1) break;
        cin >> s;
        r = 0;
        w = 0;
        memset(ans, 0, sizeof(ans));
        for (int i = 0; i < s.length(); i++){
            if (ans[s[i]-'a'] == 0){
                ans[s[i]-'a'] = 1;
                r++;
            }
        }
        cin >> s;
        flag = true;
        memset(guess, 0, sizeof(guess));
        for (int i = 0; i < s.length(); i++){
            if (guess[s[i]-'a'] == 1) continue;
            guess[s[i]-'a'] = 1;
            if (ans[s[i]-'a'] == 1){
                r--;
                ans[s[i]-'a'] = 0;
            }
            else {
                w++;
                if (w == 7 && r > 0) flag = false;
            }
        }
        cout << "Round " << n << "\n";
        if (r == 0 && flag) cout << "You win.\n";
        else if (flag) cout << "You chickened out.\n";
        else cout << "You lose.\n";
    }
}

//16-後序運算式求值 
#include <iostream>
#include <string>
#include <stack>
using namespace std;

int main() {
	cin.sync_with_stdio(false); cin.tie(nullptr);
	int buffer1, buffer2;
	stack <int> numbers;
	string expression;
	while (cin >> expression)
		if (isdigit(expression[0]) || (expression.size() > 1))
			numbers.push(stoi(expression));
		else {
			buffer2 = numbers.top(); numbers.pop();
			buffer1 = numbers.top(); numbers.pop();
			switch (expression[0]) {
			case '+':
				numbers.push(buffer1 + buffer2);
				break;
			case '-':
				numbers.push(buffer1 - buffer2);
				break;
			case '*':
				numbers.push(buffer1 * buffer2);
				break;
			case '/':
				numbers.push(buffer1 / buffer2);
				break;
			}
		}
	cout << numbers.top() << '\n';
}

//17-一堆石頭
#include <iostream>
using namespace std;

int main (){
	int n ; 
	int arr[10] = {0};
	while (cin >>n ){
		arr[n]	++;
	}

	for (int i = 0; i<10; i++){
		if (arr[i]%3){
			cout << i;
			break;
		}
	}
	
}

//18-團體佇列Team Queue
#include <iostream>
#include <cstring>
#include <string>
#include <queue>
#include <map>
using namespace std;

struct team {
	int amount;
	queue <int> order;
};

int main() {
	cin.sync_with_stdio(false), cin.tie(nullptr);
	int amount, number, teamNumber, timeCount = 1;
	bool haveTeam[1000];
	string command;
	while (cin >> amount, amount) {
		team teams[1000];
		queue <int> teamQueue;
		map <int, int> belong;
		memset(haveTeam, false, sizeof(haveTeam));
		cout << "Scenario #" << timeCount++ << '\n';
		for (int i = 0; i < amount; ++i) {
			cin >> teams[i].amount;
			for (int j = 0; j < teams[i].amount; ++j)
				cin >> number, belong[number] = i;
		}
		while (cin >> command, command != "STOP") 
			if (command == "ENQUEUE") {
				cin >> number, teamNumber = belong[number];
				if (!haveTeam[teamNumber])
					teamQueue.push(teamNumber), haveTeam[teamNumber] = true;;
				teams[teamNumber].order.push(number);
			}
			else {
				teamNumber = teamQueue.front();
				cout << teams[teamNumber].order.front() << '\n';
				teams[teamNumber].order.pop();
				if (teams[teamNumber].order.empty())
					teamQueue.pop(), haveTeam[teamNumber] = false;
			}
		cout << '\n';
	}
}

//19-I Can Guess the Data Structure!
#include <iostream>
#include <queue>
#include <stack>

using namespace std;

int main()
{
	ios::sync_with_stdio(false);
	cin.tie(nullptr);
	cout.tie(nullptr);

	int n, in, x;
	
	while (cin >> n) {

		queue<int> q;
		priority_queue<int> pq;
		stack<int> s;
		bool isq = true, ispq = true, iss = true;

		while (n--) {

			cin >> in >> x;

			if (in == 1) {
				q.emplace(x);
				pq.emplace(x);
				s.emplace(x);
			}
			else {
				if (isq)
					if (!q.empty() && q.front() == x) q.pop();
					else isq = false;
				if (ispq)
					if (!pq.empty() && pq.top() == x) pq.pop();
					else ispq = false;
				if (iss)
					if (!s.empty() && s.top() == x) s.pop();
					else iss = false;
			}
		}

		if ((isq && iss) || (isq && ispq) || (ispq && iss)) cout << "not sure\n";
		else if (isq) cout << "queue\n";
		else if (ispq) cout << "priority queue\n";
		else if (iss) cout << "stack\n";
		else cout << "impossible\n";
	}

	return 0;
}

//20-Add All
#include <iostream>
#include <queue>

using namespace std;

int main()
{
	int n,d;
	while (cin >> n && n) {
		priority_queue<int, vector<int>, greater<int>> pq;
		for (int i = 0;i<n;i++)
			{
				cin >>d;
				pq.push(d);
			}
		long long sum ,cost =0;
		while (pq.size() !=1)	{
			sum = pq.top();
			pq.pop();
			sum+=pq.top();
			pq.pop();
			cost +=sum;
			pq.push(sum);
		}
		cout << cost <<endl;
	}

	return 0;
}

//22-數位占卜
#include <iostream>
#include <string>
#include <stack>
using namespace std;

int main() {
    string s; 
    stack<string> ss;  
    stack<int> nums; 
    while(cin >> s) ss.push(s); 
    while(!ss.empty()) { 
        s = ss.top(); ss.pop();  
        if (s == "f") { 
            int x = nums.top(); nums.pop();  
            nums.push(2*x - 3);  
        } else if (s == "g") {  
            int x = nums.top(); nums.pop(); 
            int y = nums.top(); nums.pop();  
            nums.push(2*x + y - 7); 
        }  else if (s == "h") {
            int x = nums.top(); nums.pop();  
            int y = nums.top(); nums.pop(); 
            int z = nums.top(); nums.pop(); 
            nums.push(3*x - 2*y + z);  
        } else {  
            nums.push(stoi(s)); 
        }
    }
    cout << nums.top() << endl; 
    return 0;
} 

//23-DF-expression 
#include <bits/stdc++.h>

using namespace std;

string s;
int n;
long long int ans=0;
int power;

int backtrack(int layer ,int start){
    int a=0;
    for (int i=start ;i<s.size();i++){
        a++;
        if (s[i]=='1') ans+= pow(2,abs(power-layer))*pow(2,abs(power-layer));
        if (s[i]=='2'){
            i=backtrack(layer+1, i+1);
        }
        if (a>=4) return i;
        
    }
    return s.size()-1;
}

int main()
{
    ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);
    
    cin>>s>>n;
    power = log10(n)/log10(2);
    backtrack(0,0);
    cout<<ans;
    return 0;
}

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int idx=0;
string track;
//24-磁軌移動序列 
ll seq(int &head, int &tail) {
    ll total = 0, t;
    head = tail = -1;
    while (true) {
        if (idx>=track.length()) return total;
        if (track[idx]=='T') {
            t = stoi(track.substr(idx+1,2));
            idx += 3;
            if (tail<0) head = t;
            else total += abs(tail-t);
            tail = t;
        } else if (track[idx]=='L') {
            t = stoi(track.substr(idx+1,1));
            idx += 2;
            int h,e;
            ll cost = seq(h,e);
            if (tail<0) head = h;
            else total += abs(tail-h);
            tail = e;
            total += cost*t+abs(h-e)*(t-1);
        } else { // E
            idx += 1;
            return total;
        }
    }
}

int main() {
    int xx,i,j;
    cin >>track;
    ll total = seq(i,j);
    total += abs(10-i);
    cout << total <<endl;
    return 0;
}
